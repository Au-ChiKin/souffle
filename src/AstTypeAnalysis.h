/*
 * Souffle - A Datalog Compiler
 * Copyright (c) 2019, The Souffle Developers. All rights reserved.
 * Licensed under the Universal Permissive License v 1.0 as shown at:
 * - https://opensource.org/licenses/UPL
 * - <souffle root>/licenses/SOUFFLE-UPL.txt
 */

/************************************************************************
 *
 * @file AstTypeAnalysis.h
 *
 * A type analysis class operating on AST programs.
 *
 ***********************************************************************/

#pragma once

#include "AnalysisType.h"
#include "AstAnalysis.h"
#include "AstArgument.h"
#include "AstNode.h"
#include "AstVisitor.h"
#include "TypeConstraint.h"
#include "TypeLattice.h"
#include "Util.h"
#include <cassert>
#include <map>
#include <memory>
#include <ostream>
#include <set>
#include <string>
#include <vector>

namespace souffle {

class AstClause;
class AstProgram;
class AstTranslationUnit;

/**
 * A type solver that computes the type for each argument in a given clause.
 **/
class TypeSolver {
public:
    /**
     * TypeSolver constructor.
     *
     * @param program the program containing the clause
     * @param lattice the associated type lattice constructed for the program
     * @param clause the clause to be analysed
     * @param logStream a pointer to the stream where debugging information should be printed
     */
    TypeSolver(const AstProgram* program, const TypeLattice* lattice, const AstClause* clause,
            std::stringstream* logStream = nullptr)
            : program(program), lattice(lattice), clause(clause), logStream(logStream) {
        generateConstraints();
        resolveConstraints();
    }

    /** Get the type lattice associated with the type solution */
    const TypeLattice* getLattice() const {
        return lattice;
    }

    /** Checks if a type has been computed for the given argument */
    bool hasType(const AstArgument* arg) const {
        return typeMapping.find(getRepresentative(arg)) != typeMapping.end();
    }

    /** Get the computed type stored in the lattice for the given argument */
    const AnalysisType* getType(const AstArgument* arg) const {
        auto pos = typeMapping.find(getRepresentative(arg));
        assert(pos != typeMapping.end() && "argument does not have a type");
        return pos->second;
    }

    /** Set the type of a given argument */
    void setType(const AstArgument* arg, const AnalysisType* type) {
        typeMapping[getRepresentative(arg)] = lattice->getStoredType(*type);
    }

    /** Gets the set of type constraints generated by the clause */
    std::set<TypeConstraint*> getConstraints() const {
        return toPtrSet(constraints);
    }

    void print(std::ostream& out) const {
        for (const auto& pair : typeMapping) {
            assert(pair.first != nullptr && "nullptr argument in type solution");
            assert(pair.second != nullptr && "nullptr analysis type in type solution");
            out << "type(" << *pair.first << ") = " << *pair.second << std::endl;
        }
    }

private:
    const AstProgram* program;
    const TypeLattice* lattice;
    const AstClause* clause;
    std::stringstream* logStream;
    std::set<std::unique_ptr<TypeConstraint>> constraints{};
    std::map<const AstArgument*, const AnalysisType*> typeMapping{};
    mutable std::map<const std::string, const AstVariable*> representatives{};

    /** Adds a constraint that needs to be satisfied by the type solution. */
    void addConstraint(std::unique_ptr<TypeConstraint> constraint) {
        constraints.insert(std::move(constraint));
    }

    /** Generates the set of type constraints associated with the clause */
    void generateConstraints();

    /** Resolves all stored constraints until they are simultaneously satisfied */
    void resolveConstraints();

    /**
     * Gets the canonical representative of a given argument.
     * - For variables, this is a variable pointer that represents all variables
     * bound to the same name.
     * - For non-variables, this is the argument pointer itself.
     **/
    const AstArgument* getRepresentative(const AstArgument* arg) const;
};

/** Type analysis entrypoint */
class TypeAnalysis : public AstAnalysis {
public:
    TypeAnalysis() = default;

    static constexpr const char* name = "type-analysis";

    void run(const AstTranslationUnit& translationUnit) override;

    void print(std::ostream& out) const override {
        if (lattice->isValid()) {
            out << logStream.str();
        } else {
            out << "Unable to run type analysis: valid type lattice could not be constructed";
        }
    }

    /** Get the computed type stored in the lattice for the given argument */
    const AnalysisType* getType(const AstArgument* arg) const {
        assert(lattice->isValid() && "cannot determine type in invalid lattice");
        auto pos = typeSolutions.find(arg);
        assert(pos != typeSolutions.end() && "argument does not have a type");
        return pos->second;
    }

    /** Get the type lattice associated with the analysis */
    const TypeLattice* getLattice() const {
        return lattice.get();
    }

    /** Gets the set of all clauses that have been assigned a type */
    const std::vector<const AstClause*>& getTypedClauses() const {
        return typedClauses;
    }

    /** Checks whether any clauses could not be typechecked */
    bool foundInvalidClauses() const {
        return hasInvalidClauses;
    }

    /** Checks whether a clause can be typechecked in a given program */
    static bool isInvalidClause(const AstProgram* program, const AstClause* clause);

private:
    std::unique_ptr<TypeLattice> lattice{};
    std::map<const AstArgument*, const AnalysisType*> typeSolutions{};
    std::vector<const AstClause*> typedClauses{};
    bool hasInvalidClauses{false};
    std::stringstream logStream{};
};

}  // end of namespace souffle
